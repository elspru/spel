{
  "name": "parallel",
  "description": "Create tasks in node.js that run in parallel, or sequences that run tasks one after another.",
  "version": "0.2.1",
  "author": {
    "name": "Tim Smart"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/Tim-Smart/node-parallel.git"
  },
  "engine": [
    "node >=0.1.90"
  ],
  "main": "lib/parallel",
  "readme": "Usage\n=====\n\n    var Task = require('parallel').Task;\n\n    // Here is your typical async function\n    var myAsyncFunction = function myAsyncFunction(id, callback) {\n      database.getEntry(id, function (data) {\n        callback(data);\n      });\n    };\n\n    // We want to make a task that executes `myAsyncFunction` and passes\n    // 1 & 3 as the first argument. Note: You do not need to supply a\n    // callback argument\n\n    // Every 'task entry' needs a unique id so it can be identified later.\n    var myTask = new Task({\n      1: [myAsyncFunction, 1], // This task has the id `1`, calls myAsyncFunction\n                               // and passes `1` as the first argument\n      2: [myAsyncFunction, 3]  // This task has the id `2`, calls myAsyncFunction\n                               // and passes `3` as the first argument\n    });\n\n    // We can then add 'listeners' to task entries using `bind`, and\n    // referencing the entry id\n\n    // We pass a callback as the last argument, which is called like\n    // it was passed directly to the async function.\n    myTask.bind(1, function (data) {\n      doSomethingWith(data);\n    });\n\n    // We can also bind to multiple entries\n    myTask.bind(1, 2, function (data) {\n      doSomethingElseWith(data);\n    });\n\n    // We then run the task with `run`. The only argument is a callback\n    // which is passed the entry id as the first argument, and the additional\n    // returned arguments are suffixed. The task id is `null` when everything\n    // is finished.\n    myTask.run(function (entry_id, data) {\n      // This will be true when everything is done\n      if (entry_id === null) {\n        moveOnAndDoSomethingElse();\n      }\n\n      // This is true when entry 1 is done\n      else if (entry_id === 1) {\n        doSomethingWith(data);\n      }\n\n      // This is true when entry 2 is done\n      else if (entry_id === 2) {\n        doSomethingElseWith(data);\n      }\n    });\n\n    // You can also add tasks dynamically\n    // This will create 2 task entries that have the id's 0 & 1, and call\n    // `myAsyncFunction` with the first argument as 0 & 2 respectivly\n    myTask = new Task();\n\n    for (var i = 0; i < 2; i++) {\n      myTask.add(i, [myAsyncFunction, i * 2]);\n    }\n\n    // We can then bind and run the task like before\n\nAlso some usage of `Sequence`:\n\n    var Sequence = require('parallel').Sequence,\n        fs       = require('fs'),\n        path     = require('path'),\n        sys      = require('sys');\n\n    // Create a new sequence, pass in an array of funcions, or\n    // pass them as arguments\n    var task = new Sequence([\n      function (next) {\n        // First argument is always a function that gets called on completion\n        sys.puts('Hello world. We are starting!');\n        fs.readFile(__filename, next);\n      },\n      function (next, err, buffer) {\n        // The extra args gets suffixed onto the arguments\n        sys.puts('The size of this example is: ' + buffer.length);\n\n        // next.parallel is a variable you can pass which\n        // enables you to do  multiple tasks at once.\n        // It should only be used in cases where the expected\n        // arguments passed to the callback are: error, result\n        fs.readdir(__dirname, next.parallel);\n        fs.readdir(path.join(__dirname, 'lib'), next.parallel);\n      }\n    ]);\n\n    // You can also add tasks with the add method. This also opens\n    // up dynamic task creation as an option\n    task.add(function (next, err, results, first, second) {\n      // The returned arguments from a parallel sequence\n      // are as follows:\n      // * Callback for next task (as usual)\n      // * Error is there was one, otherwise will be null\n      // * All the results as an array in order\n      // * The result of the first task\n      // * Result of second task\n      // etc.\n      sys.puts('This dir had ' + results[0].length + ' items.');\n      sys.puts('The lib directory has ' + second.length + ' items.');\n\n      // You can either make the last changes here, or call next\n      // to run the callback passed to run(). You can pass arguments\n      // as usual.\n      next('Done.');\n    });\n\n    task.run(function (text) {\n      // The callback to run is optional, and only gets called if the last\n      // entry called next, or next.parallel.\n      // Only difference is that callback function will not be the first\n      // arguments.\n      sys.puts(text);\n    });\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Tim-Smart/node-parallel/issues"
  },
  "_id": "parallel@0.2.1",
  "dist": {
    "shasum": "6abe45a828d2f4b97c1a94ecf1b0d067360312b4"
  },
  "_from": "parallel@",
  "_resolved": "https://registry.npmjs.org/parallel/-/parallel-0.2.1.tgz"
}
